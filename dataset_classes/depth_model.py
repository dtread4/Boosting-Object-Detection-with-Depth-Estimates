# David Treadwell

import numpy as np

from abc import ABC, abstractmethod

import cv2

from depth_anything_3.api import DepthAnything3


class DepthModel:
    """
    Factory class to initialize a depth model
    """
    _available_depth_models = {}

    @classmethod
    def initialize_depth_model(cls, model_name, **kwargs):
        """
        Class method to load the specified model

        Args:
            model_name: The name of the depth model to use

        Raises:
            ValueError: If an invalid depth model is passed in, then raise an error

        Returns:
            The initialized depth model, or None if no depth model is specified
        """
        if model_name is None:
            print("NOT using a depth model (RGB inputs)\n")
            return None

        model_name = model_name.lower()
        if model_name not in cls._available_depth_models:
            raise ValueError(f"Unknown model type: {model_name}! Should be in this set of values:\n{cls._available_depth_models}")
        
        print(f"Using depth (RGB-D inputs) generated by depth model: {model_name}\n")
        return cls._available_depth_models[model_name](**kwargs)
    

def register_model(model_name):
    """
    Decorator to auto-register each depth model class with the DepthModel factory class
    These will be registered above each class

    Args:
        model_name: The name of the model to register
    """
    def decorator(cls):
        DepthModel._available_depth_models[model_name] = cls
        return cls
    return decorator


class _DepthModelBase(ABC):
    """
    Class to automatically manage the user-specified depth model and its calls/returns

    Args:
        ABC: Enforces abstract base class implementation
    """
    def __init__(self, device, model_path=None):
        self.device = device
        self.model_path = model_path
        self.model = self._load_model()

    @abstractmethod
    def _load_model(self):
        """
        Loads the model and places it on the object's device.
        Implementation may vary depending on the model
        """
        pass

    @abstractmethod
    def calculate_depth_map(self, input_image):
        """
        Calculates the depth map for a specified input image

        Args:
            input_image: _description_

        Returns:
            A 2D numpy array [h, w] of the estimated depths
        """
        pass

    def _normalize_depth_mask(self, depth_map):
        """_summary_

        Args:
            depth_map: _description_

        Returns:
            _description_
        """
        min_val = np.min(depth_map)
        max_val = np.max(depth_map)

        # If no unique depths are computed, return an array of 0's
        if min_val == max_val:
            return np.zeros(depth_map.shape).astype(np.float32)
        
        # Convert to float and normalize
        normalized_image = (depth_map - min_val) / (max_val - min_val)
        return normalized_image


@register_model("depth_anything_v3")
class DepthAnythingv3(_DepthModelBase):
    """
    Model class for the Depth Anything 3 model
    https://github.com/ByteDance-Seed/Depth-Anything-3/

    Implementation of the Depth Model base class

    Args:
        DepthModel: The base class this class is an implementation of
    """
    def __init__(self, device, model_path=None, da3_model_name="da3-small"):
        self.da3_model_name = da3_model_name
        super().__init__(device, model_path)

    def _load_model(self):
        """
        Loads the correct Depth Anything 3 model from Hugging Face and places it on the object's device.
        """
        return DepthAnything3.from_pretrained(f"depth-anything/{self.da3_model_name}").to(self.device)
    
    def calculate_depth_map(self, input_image):
        """
        Calculates the depth map for a single input image and return it in the form [h, w]

        Args:
            input_image: The input image to calculate depth for

        Returns:
            A depth map in the form [h, w]
        """
        # TODO this model uses relative outputs; may want to try a version that uses absolute ones
        # The process_res parameter will have Depth Anything 3 use the closest available resolution
        # to the original input images shape.
        # The process_res_method will have Depth Anything 3 assume that the resolution being passed in corresponds to
        # the long side of the image.
        # https://github.com/ByteDance-Seed/Depth-Anything-3/blob/main/docs/API.md

        cv2.imshow('org image', cv2.cvtColor(input_image, cv2.COLOR_RGB2BGR))
        cv2.waitKey()

        images = [input_image]
        prediction = self.model.inference(
            images,
            process_res=max(input_image.shape[0], input_image.shape[1]),
            process_res_method="upper_bound_resize"
        )
        depth_map = prediction.depth[0]

        print(depth_map)

        cv2.imshow('depth map', depth_map)
        cv2.waitKey()

        # The output depth map is resized to the original image's resolution
        depth_map_resized = cv2.resize(
            depth_map, (input_image.shape[1], input_image.shape[0]), 
            interpolation=cv2.INTER_LINEAR
        )

        cv2.imshow('depth map resized', depth_map_resized)
        cv2.waitKey()

        normalized_depth_mask = self._normalize_depth_mask(np.array(depth_map_resized))
        
        return normalized_depth_mask

